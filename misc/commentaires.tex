\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{color}
\usepackage{hyperref}

\begin{document}

\newcommand{\vic}[1]{\textcolor{blue}{#1}}
\newcommand{\fra}[1]{\textcolor{red}{#1}}



\section{TO DO list}
\begin{itemize}
  \item Parsing et AST~;
  \item Sémantique des termes~; 
  \item Sémantique des valeurs~;
  \item Sémantique des processeurs~;
  \item Implémenter un système de canaux~;
  \item Soit finir les extracteurs, soit utiliser de la composition~;
  \item Plein d'autres trucs... .
\end{itemize}
\section{DONE}
\section{Log}

\paragraph{ Vendredi 31 } : Début du projet. On a commencé à implémenter les classes termes, valeurs et processus.
\section{Conventions}

Convention de nommage :
\begin{itemize}
\item nom de classe par une majuscule~;
\item Pour les noms composes on utilise des majuscule~;
\item commentaires en scala doc~;
\item Au mieux, sauf pour les case classes, une classe par fichier~;
\item Les attributs, afin de les différencier des variables finissent par \_m~;
\item Indentation à 4 espaces~;
\end{itemize}
\section{Commentaires}
\paragraph{Ajouts :}
\vic{La classe TermValue que tu as ajouté, c'est pour faire de la composition ? Parce que pour les extractors il n'y en a pas besoin, il y a déjà une classe Value équivalente définie dans values.scala. Si c'est pour la compo, alors oublie ce que j'ai dit. 
Autrement, la classe TermList est de type List[Term] je pense.}

\paragraph{Extractors :}
\fra{Je doute encore afin de savoir si c'est la bonne façon de faire. Cette histoire d'objet au lieu de classe etc... me perturbe. Utiliser de la composition peut s'avérer pas si mal. Je ne sais pas ce que tu en penses...}

\vic{Je sais pas si c'est la bonne façon, mais en tout cas, c'est la manière conseillée par le compilo plutôt que d'imbriquer des case classes. J'ai testé la composition, ça me parrait un peu moins flexible, et un peu plus lourd : il faut d'abord déclarer un objet du type voulu (du style ValueInteger) et l'envoyer après en paramètre à une classe Value qui va le stocker. }
\fra{Explique moi cette histoire de définir d'abord une classe puis un objet, c'est complètement louche ton truc}
\vic{J'ai peut être mal compris la composition.. Pour moi, ça revient à avoir une classe TermValue qui a un attribut de type Value sur lequel on va matcher. Le problème c'est qu'il faut bien instancier cet argument avant de le passer à TermValue non ?}

\paragraph{Commentaires :}
\fra{Le Java est un langage assez normalisé, beaucoup de \textit{bureaucratie} comme dirait Julius. Pour ce projet, je pense qu'on peut en profiter pour s'habituer aux conventions. Comme doxygene en C++, il existe des générateurs de doc pour Java, et donc Scala. Pour cela, il faut utiliser des commentaires un peu spéciaux. Je regarde sur internet en ce moment même pour en savoir un peu plus.}
\vic{
Tu m'expliqueras comment on fait, que je normalise mes commentaires, ils sont faits un peu n'importe comment là. 
A part ça, je vais tout de suite renommer mes attributs avec le \_m à la fin.
}
\fra{Tu regardes ici \url{https://wiki.scala-lang.org/display/SW/Writing+Documentation}, j'ai commencé à faire un truc, on va voir si l'algorithme de merge fonctionne bien.}

\paragraph{sbt : } 
\fra{L'équivalent du Makefile pour Scala c'est l'utilitaire sbt.
Pour l'instant faut que tu l'installes :}
\newline
\url{http://www.scala-sbt.org/0.12.2/docs/Getting-Started/Setup.html}
<<<<<<< Updated upstream
Je regarde le reste...}

\vic{Pas de problème, j'installe ça..}
\newline
\fra{
Pour compiler, tu te places dans le dossier interpreter. Tu lances sbt. La première fois c'est lon, et ensuite tu éxécutes la commande run et c'est parti.}

\end{document}
